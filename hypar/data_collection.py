import csv
import os
import datetime
import pyEX.stocks as pyex
from portfolio import Portfolio
from stock import StockData, StockSegment, Stock


def generate_portfolio():
    """ Main method for creating a Portfolio that contains Stocks and data.

        Internal functions:
            check_for_api_tokens():
                Assigns the API token and version to use when calling the API.

                The user specifies the version of the IEX Cloud API to call.
                    - "stable" calls real API data; counts towards monthly API
                        allowance
                    - "sandbox" calls fake API data; does not count towards
                        monthly API allowance

                If the user has previously used that version before, the API
                token will be retrieved, and does not require re-entering by
                the user.

                Returns:
                    API version corresponding token to collect data.

            define_iex_call():
                Set the time frame and data to be collected from the API.

                The pre-determined time frames align with those defined in the
                API. Enter the number corresponding to the kind of data to call
                from the API. Each number corresponds to a function defined by
                the pyEX library and a unit cost (if using any other version of
                IEX besides "sandbox").

                The input string of numbers are then split and subsequently
                used to call the method contained in pyEX, obtain the data from
                IEX, and create StockSegments and Stocks.

                Returns:
                    IEX API call specifications (i.e., data types and time
                    frame)
            # TODO Update description
            generate_stock_segment(ticker, start, end, position_in_list):
                Main method for creating Stocks based on user specified
                information.

                A Stock is first generated by setting its ticker, which is
                based on user input. From the specified information to be
                collected from IEX, a Stock's other attributes are subsequently
                assigned with the appropriate information in accordance with
                the IEX version, token, and time frame.

                Returns:
                    A Stock object containing information on the stock.
    Returns:
        The Portfolio containing user requested stocks and data.
    """

    def check_for_api_tokens():
        """Assigns the API token and version to use when calling the API.

        The user specifies the version of the IEX Cloud API to call.
            - "stable" calls real API data; counts towards monthly API allowance
            - "sandbox" calls fake API data; does not count towards monthly API
                allowance

        If the user has previously used that version before, the API token will
        be retrieved, and does not require re-entering by the user.

        Returns:
            API version's corresponding token to collect data.
        """
        # Name of the csv .txt file that contains user-specific API tokens.
        tokens = 'iex_api_tokens.txt'

        # Ask for which version of the API to call.
        api_env = input(
            'Enter "stable" for real data and "sandbox" for test data: ')

        # Check if iex_api_tokens.txt exists.
        if os.path.exists(tokens):
            # Check to see if this version token exists in the .txt file.
            with open(tokens, 'r') as csv_file:
                reader = csv.DictReader(csv_file, delimiter=',')
                version_exists = [False, None]
                for row in reader:
                    # If it does, set the api key to be used to call the data.
                    if row['version'] == api_env:
                        version_exists[0] = True
                        version_exists[1] = row['token']
                if version_exists[0]:
                    print('Version already exists')
                    api_key = version_exists[1]
                # If the version has not been used before, ask the user for the
                # version token and at the information to the .txt file.
                else:
                    print('Version does not already exist')
                    api_key = input('Enter your IEX Cloud API key: ')
                    with open(tokens, 'a') as csv_file:
                        fields = ['version', 'token']
                        writer = csv.DictWriter(csv_file, fieldnames=fields)
                        writer.writerow({'version': api_env, 'token': api_key})

        # .txt file does not exist.
        else:
            api_key = input('Enter your IEX Cloud API key: ')

            # Add the version/token entry to the .txt file.
            with open(tokens, 'a') as csv_file:
                fields = ['version', 'token']
                writer = csv.DictWriter(csv_file, fieldnames=fields)
                writer.writeheader()
                writer.writerow({'version': api_env, 'token': api_key})
        return api_env, api_key

    def define_iex_call():
        """ Set the time frame and data to be collected from the API.

        Enter the beginning and end of the time frame scope. This range is
        used to define an appropriate time frame call to the API. Enter the
        number corresponding to the kind of data to call from the API. Each
        number corresponds to a function defined by the pyEX library and a
        unit cost (if using any other version of IEX besides "sandbox").

        The input string of numbers are then split and subsequently used to
        call the method contained in pyEX, obtain the data from IEX, and assign
        it to the appropriate attribute of the Stock.

        Returns:
            IEX API call specifications (i.e., data types and time frame)
        """
        p_start = input('Portfolio start (YYYY-MM-DD): ')
        p_start = datetime.date.strptime(p_start, '%Y-%m-%d')
        p_end = input('Portfolio end (YYYY-MM-DD): ')
        p_end = datetime.date.strptime(p_end, '%Y-%m-%d')

        p_range = p_end - p_start
        first_of_year = datetime.date.today().replace(month=1, day=1)
        if p_range == datetime.date.today() - first_of_year:
            time_frame = 'ytd'
        elif p_range < datetime.timedelta(days=30):
            time_frame = '1m'
        elif p_range < datetime.timedelta(days=90):
            time_frame = '3m'
        elif p_range < datetime.timedelta(days=180):
            time_frame = '6m'
        elif p_range < datetime.timedelta(days=365):
            time_frame = '1y'
        elif p_range < datetime.timedelta(days=730):
            time_frame = '2y'
        elif p_range < datetime.timedelta(days=1825):
            time_frame = '5y'
        else:
            time_frame = 'max'

        data_dict = {1: ('interday_pricing', pyex.chart),
                     2: ('balance_sheet', pyex.balanceSheet),
                     3: ('book', pyex.book),
                     4: ('cash_flow', pyex.cashFlow),
                     5: ('company', pyex.company),
                     6: ('earnings', pyex.earnings),
                     7: ('estimate', pyex.estimates),
                     8: ('income_statement', pyex.incomeStatement),
                     9: ('intraday_pricing', pyex.intraday),
                     10: ('ipo_today', pyex.ipoToday),
                     11: ('ipo_upcoming', pyex.ipoUpcoming),
                     12: ('key_stats', pyex.keyStats),
                     13: ('price_target', pyex.priceTarget)}

        print('Type the numbers corresponding to the data of interest ('
              'separate with comma): ')
        print('[1] interday pricing')
        print('[2] balance sheet')
        print('[3] book data')
        print('[4] cash flow')
        print('[5] company data')
        print('[6] earnings')
        print('[7] analyst estimates')
        print('[8] income statement')
        print('[9] intraday pricing')
        print('[10] IPO (today)')
        print('[11] IPO (upcoming)')
        print('[12] key stats')
        print('[13] price target')

        input_data = input()
        input_data = input_data.split(',')

        for i, n in enumerate(input_data):
            input_data[i] = int(n)

        return time_frame, data_dict, input_data
    # TODO Update -- LEFT OFF HERE
    def generate_stock_segment(ticker, start, end, position_in_list):

        """ Main method for creating Stocks based on user specified information.

        A Stock is first generated by setting its ticker, which is based on user
        input. From the specified information to be collected from IEX, a
        Stock's other attributes are subsequently assigned with the appropriate
        information in accordance with the IEX version, token, and time frame.

        Returns:
            A Stock object containing information on the stock.
        """

        stk = Stock(ticker)

        for i in requested_data:
            if i == 1:
                setattr(stk,
                        ref_data[i][0],
                        ref_data[i][1](tickers[position_in_list],
                                       timeframe=timeframe,
                                       token=api_key,
                                       version=api_env))
            else:
                setattr(stk,
                        ref_data[i][0],
                        ref_data[i][1](tickers[position_in_list],
                                       token=api_key,
                                       version=api_env))

        return stk

    # Specify IEX information.
    api_env, api_key = check_for_api_tokens()

    # Specify tickers to search.
    tickers = input('Symbols (separate with comma): ')
    tickers = tickers.split(',')

    for i, t in enumerate(tickers):
        tickers[i] = t.strip()

    # Create an empty Portfolio to store the stocks.
    port = Portfolio()

    # Specify the IEX data and timeframe.
    timeframe, ref_data, requested_data = define_iex_call()

    # For each ticker listed by the user, create a Stock object
    # and add it to the Portfolio.
    for i, t in enumerate(tickers):
        stk = generate_stock(t, i)
        stk.anonymous[port] = [False, None]

        stk.portfolios.append(port)
        port.add_stock(stk)

    return port
